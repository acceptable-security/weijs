<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: contract/abi/WeiFunctionABI.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: contract/abi/WeiFunctionABI.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const BN = require('bn.js');

const WeiABIType = require('./WeiABIType.js');
const WeiUtil = require('../../WeiUtil.js');

/**
 * A class that wraps an function's ABI.
 *
 * @see {@link WeiContractFunction} uses this class to wrap it's ABI.
 */
class WeiFunctionABI {
    /**
     * Create a function ABI wrapper.
     *
     * @params {Object} abi - The ABI to be wrapped.
     */

    constructor(abi) {
        this.abi = abi;
        this.inputs = (this.abi.inputs || []).map((x) => new WeiABIType(x));
        this.outputs = (this.abi.outputs || []).map((x) => new WeiABIType(x));

        // Generate the Signature
        const args = this.abi.inputs.map((obj) => obj.type).join(",");

        this.signature = `${abi.name || 'constructor'}(${args})`;
    }

    /**
     * Encode the arguments passed to the function.
     *
     * @params {Array} args - The arguments to be encoded.
     * @returns {Buffer} The encoded arguments.
     */
    encode(args /*, packed = false */) {
        // Start with first 4 bytes of function signature
        let output;

        if ( this.abi.name ) {
            output = WeiUtil.hash(this.signature).slice(0, 4);
        }
        else {
            output = Buffer.from([]);
        }

        // How many bytes of static section
        const staticSection = this.abi.inputs.length * 32;

        // Offsets for the dynamic section
        let currOffset = staticSection;

        let dynamic = Buffer.from([]);

        // Encode static section
        for ( let i = 0; i &lt; this.inputs.length; i++ ) {
            const input = this.inputs[i];
            const parse = input.parse(args[i]);

            if ( input.isStatic ) {
                output = Buffer.concat([output, parse.encode()]);
            }
            else {
                // Size of the parsed output as a 32 byte big endian number
                const size = (new BN(parse.size())).toBuffer('be', 32);
                
                // Offset of the data in dynamic section
                const offset = (new BN(currOffset)).toBuffer('be', 32);
                output = Buffer.concat([output, offset]);

                // Actual encoded data
                const encode = parse.encode();

                // Past the size and data
                currOffset += encode.length + size.length;

                // Add size/encoded to dynamic section
                dynamic = Buffer.concat([dynamic, size, encode]);
            }
        }

        return Buffer.concat([output, dynamic]);
    }

    /**
     * Decode the result of a function
     *
     * @params {Buffer} bin - The encoded results of a function.
     * @returns {Array} The decoded arguments.
     */
    decode(bin) {
        let tmp = Buffer.from(bin);
        const outputs = [];
        const offsets = [];

        // Static section
        for ( let i = 0; i &lt; this.outputs.length; i++ ) {
            const output = this.outputs[i];
            const data = tmp.slice(0, 32);

            tmp = tmp.slice(32);

            if ( output.isStatic ) {
                // Push the parsed output
                const parsed = output.parse(data).decode();
                outputs.push(parsed);
            }
            else {
                // Make a temporary spcae and put the location of the dynamic
                // object into a offsets array
                outputs.push("tmp");
                offsets.push([i, (new BN(data)).toNumber()]);
            }
        }

        // Dynamic section
        for ( const offpos of offsets ) {
            // Get the position in the outputs and the offset in the output data
            const pos = offpos[0];
            const offset = offpos[1];

            // Get the output type
            const output = this.outputs[pos];

            // Get the actual length of the data
            const len = (new BN(bin.slice(offset, offset + 0x20))).toNumber();

            // Get the data itself
            const data = bin.slice(offset + 0x20, offset + 0x20 + len);

            // Parse and store that data into the position found above
            const parsed = output.parse(data).decode();
            outputs[pos] = parsed;
        }

        return outputs;
    }
}

module.exports = WeiFunctionABI;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Wei.html">Wei</a></li><li><a href="WeiABIType.html">WeiABIType</a></li><li><a href="WeiAccount.html">WeiAccount</a></li><li><a href="WeiAccountManager.html">WeiAccountManager</a></li><li><a href="WeiContract.html">WeiContract</a></li><li><a href="WeiContractEvent.html">WeiContractEvent</a></li><li><a href="WeiContractEventListener.html">WeiContractEventListener</a></li><li><a href="WeiContractFunction.html">WeiContractFunction</a></li><li><a href="WeiEventABI.html">WeiEventABI</a></li><li><a href="WeiFunctionABI.html">WeiFunctionABI</a></li><li><a href="WeiHttpProvider.html">WeiHttpProvider</a></li><li><a href="WeiKeyAccount.html">WeiKeyAccount</a></li><li><a href="WeiProvider.html">WeiProvider</a></li><li><a href="WeiRLP.html">WeiRLP</a></li><li><a href="WeiRPC.html">WeiRPC</a></li><li><a href="WeiRPCAccount.html">WeiRPCAccount</a></li><li><a href="WeiTransaction.html">WeiTransaction</a></li><li><a href="WeiType.html">WeiType</a></li><li><a href="WeiTypeBytes.html">WeiTypeBytes</a></li><li><a href="WeiTypeDynamic.html">WeiTypeDynamic</a></li><li><a href="WeiTypeFixed.html">WeiTypeFixed</a></li><li><a href="WeiTypeNumber.html">WeiTypeNumber</a></li><li><a href="WeiUtil.html">WeiUtil</a></li><li><a href="WeiWeb3Provider.html">WeiWeb3Provider</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Jul 05 2018 16:02:25 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
