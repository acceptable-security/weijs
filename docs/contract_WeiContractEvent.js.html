<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: contract/WeiContractEvent.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: contract/WeiContractEvent.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const EventEmitter = require('events');
const WeiEventABI = require('./abi/WeiEventABI.js');

/**
 * An event listener created by a contract. Used for event handling 
 *
 * @see {@link WeiContractEvent} for usage.
 */
class WeiContractEventListener extends EventEmitter {
    /**
     * Create an event listener object.
     *
     * @params {WeiContractEvent} event - The event we're listening for
     * @params {string} filterID - a hex encoded filter ID generated by the RPC.
     * @params {number} interval - Interval to check the RPC for event changes. Defaults to 1 second.
     * if set to 0 this will disable automatic checks.
     */
    constructor(event, filterID, interval = 1 * 1000) {
        super();

        this._event = event;
        this._filterID = filterID;
        this.interval = interval;

        if ( interval > 0 ) {
            this.listen();
        }
    }

    /**
     * Query for any new events by our filter ID. This means that once an event is found by query, it won't
     * appear in any subsequent calls.
     *
     * @returns {Array} An array of the events that have been emitted since the function was last called.
     */
    async query() {
        const filter = await this._event._wei.rpc.eth.getFilterChanges(this._filterID);
        const parsed = [];

        for ( const log of filter ) {
            parsed.push(this._event.abi.decode(log));
        }

        return parsed;
    }

    /**
     * Begin listening for the events. Will check at the rate specified in the constructor.
     *
     * @description This will repeatedly call query and emit an event when new event is found.
     * This will automatically be called by the constructor if the interval is not 0, however,
     * if {@link WeiContractEvent#cancel} is called, this can be called again to restart the
     * checks.
     */
    listen() {
        if ( this.interval == 0 ) {
            return;
        }

        // Async query function
        let queryFn = async () => {
            const events = await this.query();

            for ( const event of events ) {
                this.emit('event', event);
            }
        };

        // Wrap the async query function in an interval
        let wrapperFn = () => {
            queryFn().then(() => {
                if ( this.interval == 0 ) {
                    return;
                }

                this._timeoutID = setTimeout(wrapperFn, this.interval);
            }).catch((err) => {
                throw err;
            });
        };

        // Call the interval
        this._timeoutID = setTimeout(wrapperFn, this.interval);
    }

    /**
     * Cancel the automatic queries.
     */
    cancel() {
        clearTimeout(this._timeoutID);
    }
}

/**
 * A class that wraps an event for a given contract.
 *
 * @description When the {@link WeiContract} parses its ABI, it will generate a {@WeiContractEvent}
 * for each event specified in the ABI. When {@link WeiContract#address} is called, it will automatically 
 * pass the address down to the events it has generated. The {@link WeiContractEvent} objects are exposed
 * by the event names directly on the {@link WeiContract} objects. 
 *
 * @example
 * // Listen for any Transfer events emitted from an ERC20 token.
 * // Which will be checked every 2 seconds
 * const wei = new Wei(... provider info ...);
 * const contract = wei.contract(... erc20 abi ...);
 * contract.Transfer.listen(2 * 1000).on('event', event => {
 *     console.log(event._owner, "transfered", event._value.toString(), "to", event._spender); 
 * });
 *
 * @example
 * // Listen for any Transfer events from a specific address from an ERC20 token.
 * // Which will be checked every 2 seconds
 * const wei = new Wei(... provider info ...);
 * const contract = wei.contract(... erc20 abi ...);
 * contract.Transfer.listen({ _owner: "0x..." }, 2 * 1000).on('event', event => {
 *     console.log(event._owner, "transfered", event._value.toString(), "to", event._spender); 
 * });
 */
class WeiContractEvent {
    constructor(wei, abi, address = undefined) {
        this._address = address;
        this._wei = wei;
        this.abi = new WeiEventABI(abi);
    }

    /**
     * Create a filter and return the ID for a dict with key val pairs.
     *
     * @todo Support the AND/OR system that exists. The semantics are weird and perhaps could be
     * better wrapped in a class based system?
     * @params {Object} filterObj - key/value pairs of things to be filtered by what value
     * @returns {string} Hexidecimal encoded filter ID.
     */
    async createFilter(filterObj) {
        const filter = [this.abi.sig()];

        for ( let i = 0; i &lt; this.abi.indexInputs.length; i++ ) {
            const input = this.abi.indexInputs[i];
            const value = filterObj[input.name];

            if ( value ) {
                filter.push(input.parse(value).encode());
            }
            else {
                filter.push(null);
            }
        }

        return await this._wei.rpc.eth.newFilter({ topics: filter, address: this._address });
    }

    /**
     * Create a filter, query, and return get all matching events.
     *
     * @params {Object} filter - The filter to be passed to {@link WeiContractEvent#createFilter}.
     * @returns {Array} Array of events found by the query.
     */
    async find(filter) {
        return await new WeiContractEventListener(this, await this.createFilter(filter), 0).query();
    }

    /**
     * Create a filter to be used periodically by the {@link WeiContractEventListener}.
     *
     * @params {Object} filter - The filter to be passed to {@link WeiContractEvent#createFilter}.
     * @returns {WeiContractEventListener} The event listener generated.
     */
    async listen(filter, interval = 1 * 1000) {
        if ( interval == undefined &amp;&amp; typeof filter == 'number' ) {
            interval = filter;
            filter = {};
        }

        return new WeiContractEventListener(this, await this.createFilter(filter), interval = 1 * 1000);
    }
}

module.exports = WeiContractEvent;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Wei.html">Wei</a></li><li><a href="WeiABIType.html">WeiABIType</a></li><li><a href="WeiAccount.html">WeiAccount</a></li><li><a href="WeiAccountManager.html">WeiAccountManager</a></li><li><a href="WeiContract.html">WeiContract</a></li><li><a href="WeiContractEvent.html">WeiContractEvent</a></li><li><a href="WeiContractEventListener.html">WeiContractEventListener</a></li><li><a href="WeiContractFunction.html">WeiContractFunction</a></li><li><a href="WeiEventABI.html">WeiEventABI</a></li><li><a href="WeiFunctionABI.html">WeiFunctionABI</a></li><li><a href="WeiHttpProvider.html">WeiHttpProvider</a></li><li><a href="WeiKeyAccount.html">WeiKeyAccount</a></li><li><a href="WeiProvider.html">WeiProvider</a></li><li><a href="WeiRLP.html">WeiRLP</a></li><li><a href="WeiRPC.html">WeiRPC</a></li><li><a href="WeiRPCAccount.html">WeiRPCAccount</a></li><li><a href="WeiTransaction.html">WeiTransaction</a></li><li><a href="WeiType.html">WeiType</a></li><li><a href="WeiTypeBytes.html">WeiTypeBytes</a></li><li><a href="WeiTypeDynamic.html">WeiTypeDynamic</a></li><li><a href="WeiTypeFixed.html">WeiTypeFixed</a></li><li><a href="WeiTypeNumber.html">WeiTypeNumber</a></li><li><a href="WeiUtil.html">WeiUtil</a></li><li><a href="WeiWeb3Provider.html">WeiWeb3Provider</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Jul 05 2018 16:02:25 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
