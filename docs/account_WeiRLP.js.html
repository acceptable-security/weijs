<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: account/WeiRLP.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: account/WeiRLP.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const BN = require('bn.js');

/** Static class used for encoding and decoding RLP related data. */
class WeiRLP {
    /**
     * Encode data into an RLP encoding
     *
     * @param {(number|string|Array|Buffer|undefined|boolean)} data - Data to be encoded with RLP.
     * Note that if the string starts with 0x, it will be interpretted as a hex
     * string. The types of the contents of an Array must be of the same argument
     * types as the {@link WeiRLP.encode}.
     *
     * @returns {Object[]} The first argument is the parsed data, and the second part is
     * the data that still needs to be parsed.
     */
    static encode(data) {
        if ( typeof data == 'number' ) {
            // Special byte
            if ( data >= 0x00 &amp;&amp; data &lt;= 0x7F ) {
                if ( data == 0x00 ) {
                    return Buffer.from([ 0x80 ]);
                }
                
                return Buffer.from([ data ]);
            }

            data = (new BN(data)).toBuffer('be');
        }
        else if ( typeof data == 'string' ) {
            if ( data.substring(0, 2) == '0x' ) {
                data = Buffer.from(data.substring(2), 'hex');
            }
            else {
                data = Buffer.from(data, 'utf8');
            }
        }
        else if ( typeof data == 'boolean' ) {
            return Buffer.from([ data ? 0x01 : 0x80 ]);
        }
        else if ( typeof data == 'undefined' ) {
            return Buffer.from([ 0x80 ]);
        }
        else if ( data instanceof BN ) {
            data = data.toBuffer('be');
        }

        if ( data instanceof Buffer ) {
            if ( data.length == 0 ) {
                // Empty buffer
                return Buffer.from([ 0x80 ]);
            }
            else if ( data.length &lt;= 55 ) {
                // Short buffer
                return Buffer.concat([ Buffer.from([ 0x80 + data.length ]), data ]);
            }
            else {
                // Long buffer
                const lenBuff = (new BN(data.length)).toBuffer('be');
                return Buffer.concat([ Buffer.from([ 0xB7 + lenBuff.length]), lenBuff, data]);
            }
        }
        else if ( data instanceof Array ) {
            const elements = Buffer.concat(data.map((x) => WeiRLP.encode(x)));

            if ( elements.length == 0 ) {
                // Empty list
                return Buffer.from([ 0xC0 ]);
            }
            else if ( elements.length &lt;= 55 ) {
                // Short list
                return Buffer.concat([ Buffer.from([0xC0 + elements.length]), elements]);
            }
            else {
                // Long list
                const lenBuff = (new BN(elements.length)).toBuffer('be');
                return Buffer.concat([ Buffer.from([0xF7 + lenBuff.length]), lenBuff, elements]);
            }
        }
        else {
            throw new Error("Unknown data passed to RLP encoder");
        }
    }

    /**
     * Recursive decode method, not intended for public use.
     *
     * @private
     *
     * @params {Buffer} data - Data to be decoded.
     * @returns {(Array|Buffer)} Data that has been decoded.
     */
    static _decode(data) {
        // Special byte
        if ( data[0] &lt;= 0x7F ) {
            return [ data.slice(0, 1), data.slice(1) ];
        }

        // Short buffer
        if ( data[0] >= 0x80 &amp;&amp; data[0] &lt;= 0xB7 ) {
            const len = data[0] - 0x80;
            return [ data.slice(1, 1 + len), data.slice(1 + len) ];
        }

        // Longer buffer
        if ( data[0] >= 0xB8 &amp;&amp; data[0] &lt;= 0xBF ) {
            const metaLen = data[0] - 0xB7;
            const len = (new BN(data.slice(1, 1 + metaLen))).toNumber();

            return [ data.slice(1 + metaLen, 1 + metaLen + len), data.slice(1 + metaLen + len) ];
        }

        // Short List
        if ( data[0] >= 0xC0 &amp;&amp; data[0] &lt;= 0xF7 ) {
            const count = data[0] - 0xC0;
            data = data.slice(1);

            const list = [];

            for ( let i = 0; i &lt; count; i++ ) {
                const tmp = WeiRLP._decode(data);

                list.push(tmp[0]);
                data = tmp[1];
            }

            return [ list, data ];
        }
        
        // Long list
        if ( data[0] >= 0xF8 &amp;&amp; data[0] &lt;= 0xFF ) {
            const metaLen = data[0] - 0xF7;
            const count = (new BN(data.slice(1, 1 + metaLen))).toNumber();
            data = data.slice(1 + metaLen);

            const list = [];

            for ( let i = 0; i &lt; count; i++ ) {
                const tmp = WeiRLP._decode(data);

                list.push(tmp[0]);
                data = tmp[1];
            }

            return [ list, data ];
        }

        throw new Error(`Failed to decode byte ${data[0]}`);
    }

    /**
     * Decode RLP encoded data. Note that all RLP strings will be decoded as a buffer.
     *
     * @params {Buffer} data - Data to be decoded.
     * @returns {(Array|Buffer)} Data that has been decoded.
     */
    static decode(data) {
        return WeiRLP._decode(data)[0];
    }
}

module.exports = WeiRLP;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Wei.html">Wei</a></li><li><a href="WeiAccount.html">WeiAccount</a></li><li><a href="WeiAccountManager.html">WeiAccountManager</a></li><li><a href="WeiContract.html">WeiContract</a></li><li><a href="WeiContractEvent.html">WeiContractEvent</a></li><li><a href="WeiContractEventListener.html">WeiContractEventListener</a></li><li><a href="WeiContractFunction.html">WeiContractFunction</a></li><li><a href="WeiHttpProvider.html">WeiHttpProvider</a></li><li><a href="WeiKeyAccount.html">WeiKeyAccount</a></li><li><a href="WeiProvider.html">WeiProvider</a></li><li><a href="WeiRLP.html">WeiRLP</a></li><li><a href="WeiRPC.html">WeiRPC</a></li><li><a href="WeiRPCAccount.html">WeiRPCAccount</a></li><li><a href="WeiTransaction.html">WeiTransaction</a></li><li><a href="WeiUtil.html">WeiUtil</a></li><li><a href="WeiWeb3Provider.html">WeiWeb3Provider</a></li></ul><h3>Global</h3><ul><li><a href="global.html#validateTxObj">validateTxObj</a></li><li><a href="global.html#WeiRPCMethods">WeiRPCMethods</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Jul 05 2018 15:17:38 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
