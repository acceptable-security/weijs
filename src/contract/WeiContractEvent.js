const EventEmitter = require('events');
const WeiEventABI = require('./abi/WeiEventABI.js');

/**
 * An event listener created by a contract. Used for event handling 
 *
 * @see {@link WeiContractEvent} for usage.
 */
class WeiContractEventListener extends EventEmitter {
    /**
     * Create an event listener object.
     *
     * @param {WeiContractEvent} event - The event we're listening for
     * @param {string} filterID - a hex encoded filter ID generated by the RPC.
     * @param {number} interval - Interval to check the RPC for event changes. Defaults to 1 second.
     * if set to 0 this will disable automatic checks.
     */
    constructor(event, filterID, interval = 1 * 1000) {
        super();

        this._event = event;
        this._filterID = filterID;
        this.interval = interval;

        if ( interval > 0 ) {
            this.listen();
        }
    }

    /**
     * Query for any new events by our filter ID. This means that once an event is found by query, it won't
     * appear in any subsequent calls.
     *
     * @returns {Array} An array of the events that have been emitted since the function was last called.
     */
    async query() {
        const filter = await this._event._wei.rpc.eth.getFilterChanges(this._filterID);
        const parsed = [];

        for ( const log of filter ) {
            parsed.push(this._event.abi.decode(log));
        }

        return parsed;
    }

    /**
     * Begin listening for the events. Will check at the rate specified in the constructor.
     *
     * @description This will repeatedly call query and emit an event when new event is found.
     * This will automatically be called by the constructor if the interval is not 0, however,
     * if {@link WeiContractEvent#cancel} is called, this can be called again to restart the
     * checks.
     */
    listen() {
        if ( this.interval == 0 ) {
            return;
        }

        // Async query function
        let queryFn = async () => {
            const events = await this.query();

            for ( const event of events ) {
                this.emit('event', event);
            }
        };

        // Wrap the async query function in an interval
        let wrapperFn = () => {
            queryFn().then(() => {
                if ( this.interval == 0 ) {
                    return;
                }

                this._timeoutID = setTimeout(wrapperFn, this.interval);
            }).catch((err) => {
                throw err;
            });
        };

        // Call the interval
        this._timeoutID = setTimeout(wrapperFn, this.interval);
    }

    /**
     * Cancel the automatic queries.
     */
    cancel() {
        clearTimeout(this._timeoutID);
    }
}

/**
 * A class that wraps an event for a given contract.
 *
 * @description When the {@link WeiContract} parses its ABI, it will generate a {@link WeiContractEvent}
 * for each event specified in the ABI. When {@link WeiContract#address} is called, it will automatically 
 * pass the address down to the events it has generated. The {@link WeiContractEvent} objects are exposed
 * by the event names directly on the {@link WeiContract} objects. 
 *
 * @example
 * // Listen for any Transfer events emitted from an ERC20 token.
 * // Which will be checked every 2 seconds
 * const wei = new Wei(... provider info ...);
 * const contract = wei.contract(... erc20 abi ...);
 * contract.Transfer.listen(2 * 1000).on('event', event => {
 *     console.log(event._owner, "transfered", event._value.toString(), "to", event._spender); 
 * });
 *
 * @example
 * // Listen for any Transfer events from a specific address from an ERC20 token.
 * // Which will be checked every 2 seconds
 * const wei = new Wei(... provider info ...);
 * const contract = wei.contract(... erc20 abi ...);
 * contract.Transfer.listen({ _owner: "0x..." }, 2 * 1000).on('event', event => {
 *     console.log(event._owner, "transfered", event._value.toString(), "to", event._spender); 
 * });
 */
class WeiContractEvent {
    /**
     * Create a contract event instance.
     *
     * @param {Wei} wei - The wei instance being used.
     * @param {Object} abi - The ABI of the contract event.
     * @param {string} address = undefined - Optionally, the address of the contract.
     */
    constructor(wei, abi, address = undefined) {
        this._address = address;
        this._wei = wei;
        this.abi = new WeiEventABI(abi);
    }

    /**
     * Create a filter and return the ID for a dict with key val pairs.
     *
     * @todo Support the AND/OR system that exists. The semantics are weird and perhaps could be
     * better wrapped in a class based system?
     * @param {Object} filterObj - key/value pairs of things to be filtered by what value
     * @returns {string} Hexidecimal encoded filter ID.
     */
    async createFilter(filterObj) {
        const filter = [this.abi.sig()];

        for ( let i = 0; i < this.abi.indexInputs.length; i++ ) {
            const input = this.abi.indexInputs[i];
            const value = filterObj[input.name];

            if ( value ) {
                filter.push(input.parse(value).encode());
            }
            else {
                filter.push(null);
            }
        }

        return await this._wei.rpc.eth.newFilter({ topics: filter, address: this._address });
    }

    /**
     * Create a filter, query, and return get all matching events.
     *
     * @param {Object} filter - The filter to be passed to {@link WeiContractEvent#createFilter}.
     * @returns {Array} Array of events found by the query.
     */
    async find(filter) {
        return await new WeiContractEventListener(this, await this.createFilter(filter), 0).query();
    }

    /**
     * Create a filter to be used periodically by the {@link WeiContractEventListener}.
     *
     * @param {Object} filter - The filter to be passed to {@link WeiContractEvent#createFilter}.
     * @param {number} [interval=1000] - The interval in milliseconds to check the filter. Defaults to 1s.
     * @returns {WeiContractEventListener} The event listener generated.
     */
    async listen(filter, interval = 1 * 1000) {
        if ( interval == undefined && typeof filter == 'number' ) {
            interval = filter;
            filter = {};
        }

        return new WeiContractEventListener(this, await this.createFilter(filter), interval = 1 * 1000);
    }
}

module.exports = WeiContractEvent;